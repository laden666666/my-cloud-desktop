<!doctype html><head><meta charset="utf-8"><style>.mydoc{font-size:14px;overflow:hidden}.mydoc_blockquote{padding:12px 5px 12px 30px;margin:2em 0 0 8px;border-width:0;border-left:4px solid #f66;background-color:#f8f8f8;position:relative;border-bottom-right-radius:2px;border-top-right-radius:2px;line-height:1.6em}.mydoc_blockquote:before{position:absolute;top:14px;left:-12px;background-color:#f66;color:#fff;content:"!";width:20px;height:20px;text-align:center;line-height:20px;font-weight:700;font-family:Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:14px;border-radius:10px}code[class*=language-],pre[class*=language-]{color:#000;background:none;text-shadow:0 1px #fff;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#a67f59;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.mydoc_code{overflow-x:auto;position:relative;background-color:#f8f8f8;padding:0;line-height:1.1em;border-radius:2px;margin:1.2em 0;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AgMAAABHkjHhAAAACVBMVEWAgIBaWlo+Pj7rTFvWAAAAA3RSTlMHCAw+VhR4AAAA+klEQVQoz4WSMW7EQAhFPxKWNh2FCx+HkaZI6RRb5DYbyVfIJXLKDCFoMbaTKSw/8ZnPAPjaH2xgZcUNUDADD7D9LtDBCLZ45fbkvo/30K8yeI64pPwl6znd/3n/Oe93P3ho9qeh72btTFzqkz0rsJle8Zr81OLEwZ1dv/713uWqvu2pl+k0fy7MWtj9r/tN5q/02z89qa/L4Dc2LvM93kezPfXlME/O86EbY/V9GB9ePX8G1/6W+/9h1dq/HGfTfzT3j/xNo7522Bfnqe5jO/fvhVthlfk434v3iO9zG/UOphyPeinPl1J8Gtaa7xPTa/Dk+RIs4deMvwGvcGsmsCvJ0AAAAABJRU5ErkJggg==")}.mydoc_code_pre{padding:1.2em 1.4em;line-height:1.5em;margin:0}.mydoc_h1{margin:0 0 1em}.mydoc_h1_a{color:#2c3e50;text-decoration:none;font-size:2em}.mydoc_h1_h1{margin:45px 0 8px;padding-bottom:7px;font-size:28px}.mydoc_h2{margin:35px 0 .8em}.mydoc_h2_a{font-size:1.5em;text-decoration:none;color:#2c3e50}.mydoc_h2_a:before{content:"";display:block;margin-top:-40px;height:40px;visibility:hidden}.mydoc_h2_h2{margin:5px 0 8px;border-bottom:1px solid #ddd;font-size:22px;padding-bottom:1em}.mydoc_h3{margin:35px 0 .8em}.mydoc_h3_a{font-size:1.3em;text-decoration:none;color:#2c3e50}.mydoc_h3_a:before{content:"";display:block;margin-top:-30px;height:30px;visibility:hidden}.mydoc_h3_h3{margin:5px 0 8px;border-bottom:1px solid #ddd;font-size:18px;padding-bottom:.6em}.mydoc_h4{margin:35px 0 .8em}.mydoc_h4_a{font-size:1.2em;text-decoration:none;color:#2c3e50}.mydoc_h4_a:before{content:"";display:block;margin-top:-20px;height:20px;visibility:hidden}.mydoc_h4_h4{margin:5px 0 8px;border-bottom:1px solid #ddd;font-size:16px;padding-bottom:.3em}.mydoc_table{margin:15px 0 0;padding:0;border:1px solid #aaa;border-collapse:collapse;width:100%;color:#000;font-size:14px;background-color:#fdfcf8}.mydoc_table .mydoc_tr{margin:0;padding:0;border:0;background-color:#fff}.mydoc_table .mydoc_tr:nth-child(odd){background-color:#f5f5f5}.mydoc_table .mydoc_th,.mydoc_table .mydoc_tr:first-child{background-color:#3f3f3f}.mydoc_table .mydoc_th{margin:0;padding:5px 15px 5px 6px;border:1px solid #3f3f3f;vertical-align:baseline;text-align:left;color:#fff;width:123px;word-break:break-all;font-weight:400}.mydoc_table .mydoc_td{word-break:break-all;margin:0;padding:6px 15px 6px 6px;border:1px solid #aaa;vertical-align:text-top}.mydoc_img{display:block;max-width:100%}.mydoc_li:first-child,:not(.mydoc_li)+.mydoc_li{margin-top:10px}.mydoc_li+.mydoc_li{margin-top:-10px}.mydoc_li{margin:0;color:#34495e;margin-bottom:10px;position:relative}.mydoc_p{line-height:1.6em;margin:1.2em 0 -1.2em;padding-bottom:1.2em;position:relative;z-index:1;color:#333}.mydoc_a{color:#42b983;font-weight:400;text-decoration:none;cursor:pointer}.mydoc_strong{font-weight:600;color:#2c3e50}</style></head><article class='mydoc'>
                    <div class="mydoc_h1">
                <a class="mydoc_h1_a">
                    <h1 class="mydoc_h1_h1">和浏览器异步请求取消相关的那些事</h1>
                </a>
                <div class="mydoc_h1_content">
                    <p class="mydoc_p"> 我们开发web页面时候，也许会遇到和异步请求取消相关的问题。</p><p class="mydoc_p"> 如：在一个请求发送之后，用户做了一个取消指令，为了节省资源，我们需要把已经被用户取消的请求终止掉；或者是一个页面正在用ajax请求后台，突然页面发生了跳转，而我们未完成的ajax莫名其妙地走进了error里面了。</p><p class="mydoc_p"> 为了解决这两问题，我们今天一起看看和异步请求取消相关的那些事。</p><div class="mydoc_h2">
                    <a class="mydoc_h2_a">
                        <h2 class="mydoc_h2_h2">1.ajax的取消</h2>
                    </a>
                    <div class="mydoc_h1_content">
                        <p class="mydoc_p"> 当我们创建一个XMLHttpRequest对象的时候，我们就会发现两个api——abort和onabort，这就是终止异步请求的方法与其响应事件。</p><p class="mydoc_p"> 执行完abort之后，浏览器和被请求的服务器都会发生什么呢？<a class="mydoc_a" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#abort">MDN</a>的解释非常的简单，就是中断已发送的请求。这个请求指的是http请求，而不是tcp连接，这样就会出现一个问题，基于http请求原理，当一个请求从客户端发出去之后，服务器端收到请求后，一个请求过程就结束了，这时就算是客户端abort这个请求，服务器端仍会做出完整的响应，只是这个响应客户端不会接收罢了。</p><p class="mydoc_p"> <strong class="mydoc_strong">所以这个abort是仅给客户端使用的，不能作为供服务器端判断请求是否继续执行的依据</strong>。</p><p class="mydoc_p"> 那么被abort的请求对客户端有哪些影响呢？我们可以做一个实验。</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"abort前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
    xhr<span class="token punctuation">.</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"abort后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre>
                </figure><img class="mydoc_img"   src="https://images2015.cnblogs.com/blog/510823/201605/510823-20160527062531053-1248877235.png"/><p class="mydoc_p"> <strong class="mydoc_strong">我们可以看到readyState和status在abort之后被重置回0。</strong></p><p class="mydoc_p"> 那么我们能用这两个参数作为判断请求被abort的依据吗？首先能够让status等于0的情况太多了，如请求本地资源、网络不可用、请求超时，这些都可以让status被置0；readyState等于0能否作为请求是否被abort了还不好说，需要进一步判断，readyState等于0相当于请求未初始化，请求都已经send了readyState却等于0，笔者认为是可以作为abort的判断依据的，但是无法完全证明。</p><p class="mydoc_p"> 有没有更可靠的证明请求是否执行了abort方法呢？有，答案是使用onabort，onabort作为abort的响应函数，是最直接有效的判断abort手段。</p>
                    </div>
                </div><div class="mydoc_h2">
                    <a class="mydoc_h2_a">
                        <h2 class="mydoc_h2_h2">2.页面跳转时候ajax会自动“abort”</h2>
                    </a>
                    <div class="mydoc_h1_content">
                        <p class="mydoc_p">  笔者从前认为abort离我很远，但是在实际项目中，笔者发现页面我开发的请求经常被abort。这个abort动作当然不是我发起的，也不是用户发起的，他是浏览器自动发起的。笔者发现一个页面跳转的时候，浏览器会自动把所有响应未完成的请求执行“abort”，而响应已完成的请求则不会这样。我们可以做一个实验</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token comment">//要在chrome或者webkit内核上运行</span>
<span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//访问一个不存在的地址 取保请求不会马上响应</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span><span class="token string">"http://aaa.bbbbbbbb.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onabort</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"执行onabort"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//模拟跳转页面</span>
    location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">"http://www.baidu.com"</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre>
                </figure><p class="mydoc_p"> <span>结果网页上弹出了一个alert，显示着&quot;执行onabort&quot;。</span></p><img class="mydoc_img"   src="https://images2015.cnblogs.com/blog/510823/201605/510823-20160528095448506-1970412636.png"/><p class="mydoc_p"> 再看控制台，我们会发现status不变还是0，而readyState却是4，这也是浏览器发出的abort和手动执行abort最大不同。</p><p class="mydoc_p"> 以上测试仅在chrome上有效，ie、edge、火狐在页面跳转的时候，不会触发未完成的请求的onabort事件，但是会触发onreadystatechange事件。不管怎么讲，当页面发生跳转的时候，浏览器可能会“abort”我们的异步请求。</p>
                    </div>
                </div><div class="mydoc_h2">
                    <a class="mydoc_h2_a">
                        <h2 class="mydoc_h2_h2">3.jquery对abort的处理</h2>
                    </a>
                    <div class="mydoc_h1_content">
                        <p class="mydoc_p"> jquery又是如何对abort封装的呢？我们在使用$.ajax（包括众多用$.ajax封装的方法，如$.get、$.post）的时候，会返回一个xhr对象，这个基于$.<span>deferred.promise封装的jquery自己的对象，而不是原始的XMLHttpRequest或者ie的ActiveXObject对象。在这个对象中定义了如abort等方法，使得开发者可以手动abort一个ajax请求。</span></p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">var</span> xhr <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre>
                </figure><p class="mydoc_p"> 另外，jquery的超时也是通过setTimeout和abort实现的，所以当你使用jquery发出的请求超时的时候，实际上是被jquery把请求abort了。如何区分jquery的超时和手动abort呢？方法就是靠stutusText，对于timeout和abort两个客户端做出的响应，jquery会给stutusText设定固定的值，abort的时候，stutusText的值为“abort”，超时的时候stutusText值是“timeout”。</p>
                    </div>
                </div><div class="mydoc_h2">
                    <a class="mydoc_h2_a">
                        <h2 class="mydoc_h2_h2">4.jquery与页面跳转的ajax“abort”</h2>
                    </a>
                    <div class="mydoc_h1_content">
                        <p class="mydoc_p"> 如果仅仅是页面跳转的时候，chrome浏览器会自动执行未完成的请求的abort方法，那笔者也不会专门写一个章节去分析这个过程。因为笔者发现<strong class="mydoc_strong">jquery的$.ajax这个方法中，未完成的ajax在页面跳转的时候，也会触发error事件，而且你区分不出来是浏览器取消还是请求真的发生了error</strong>。</p><p class="mydoc_p"> 大家可以运行如下代码，在ie和chrome两大浏览器下都会弹出的alert对话框。</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">var</span> xhr <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    type<span class="token punctuation">:</span><span class="token string">"get"</span><span class="token punctuation">,</span>
    url<span class="token punctuation">:</span><span class="token string">"http://aaa.bbbbbbbb.com"</span><span class="token punctuation">,</span>
    error<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"执行onerror"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//模拟跳转页面</span>
    location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">"http://www.baidu.com"</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre>
                </figure><img class="mydoc_img"   src="https://images2015.cnblogs.com/blog/510823/201605/510823-20160528104310084-729156828.png"/><p class="mydoc_p"> 页面一跳转就进error，而且status和readyState都是0，stutusText仅仅显示一个“error”，jquery真是让人佩（蛋）服（疼）的五体投地-_-||。</p><p class="mydoc_p"> 为什么会这样呢？那么jquery又是如何处理onabort的呢？</p><p class="mydoc_p"> <span>笔者发现jquery1.x和2.x都会触发这个现象，所以分别参考jquery1.x和2.x的源码讨论。</span></p><p class="mydoc_p"> <span>jquery1.x其实并没有监听onabort事件，而是统一监听onreadystatechange（具体可以参考github的</span><a class="mydoc_a" href="https://github.com/jquery/jquery/blob/1.12-stable/src/ajax/xhr.js">xhr.js</a><span>和</span><a class="mydoc_a" href="https://github.com/jquery/jquery/blob/1.12-stable/src/ajax.js">ajax.js</a><span>源码），根据status是否是成功响应的http状态码，来确定执行error还是success方法。同时，jquery也没有获取浏览器的readyState的值，而是通过status是否为0去计算自己的xhr.readyState，可以说所有的响应全是靠status一个变量决定的，这就导致了我们无法区分浏览器取消事件还是真正的错误的问题。</span></p><p class="mydoc_p"> 在jquery2.x中，不再仅监听onreadystatechange（具体可以参考github的<a class="mydoc_a" href="https://github.com/jquery/jquery/blob/2.2-stable/src/ajax.js">xhr.js</a>和<a class="mydoc_a" href="https://github.com/jquery/jquery/blob/2.2-stable/src/ajax.js">ajax.js</a>源码），而是对onload、onerror、onabort（不支持onabort事件的ie9还是监听的onreadystatechange事件）全面监听，并由这些响应事件的结果去确定究竟执行error还是success。这个处理看似更合理了，然而却并没有什么卵用，因为没有监听chrome浏览器的readyState实际值，仍然是通过status去计算readyState，所以仍然会触发<span>error事件，而且xhr.readyState的值还是0，stutusText还是仅仅显示一个“error”。</span></p><p class="mydoc_p"> 说白了这就是jquery的一个bug，仅仅是根据status是否为0去判断ajax结果，同时不返回浏览器真正的readyState值；当然我们也可以说是浏览器的bug，为什么chrome浏览器在页面跳转的时候要abort的请求呢。</p><p class="mydoc_p"> 不管怎么样，笔者建议<strong class="mydoc_strong">在使用jquery的$ajax做异步请求的时候，千万不要在error回调中使用系统的模态框（如alert、confirm等）</strong>，否则用户在使用你的页面的时候经常会出现意想不到的弹框。</p>
                    </div>
                </div><div class="mydoc_h2">
                    <a class="mydoc_h2_a">
                        <h2 class="mydoc_h2_h2">5.fetch及promise如何取消与取消处理的</h2>
                    </a>
                    <div class="mydoc_h1_content">
                        <p class="mydoc_p"> fetch作为ajax的升级版，越来越多的浏览器已经支持他了，那fetch又是如何取消异步请求的呢？<strong class="mydoc_strong">答案是fetch暂时不能被取消...，因为没有对应的api。</strong></p><p class="mydoc_p"> 虽然不能取消，但是还是有替代品，当然这只是自欺欺人的做法，因为fetch根本没有被真正取消，他的资源也没有被释放。</p><p class="mydoc_p"> 标题和fetch挂钩，这让笔者感觉有点大，因为笔者现在的项目中还不准备使用fetch。实际上笔者更想聊一聊我对abort和promise的看法，因为不管我们用不用fetch，将异步请求封装成promise供后续处理都是我们现在开发的主流做法，那么如何用promise做abrot呢？</p><p class="mydoc_p"> promise仅有两个完成态，resolved和rejected。一个可以当做success处理，另一个可以当做error处理。那我们的abort的结果应该算在哪个里面呢？abort肯定不能将其看成success，但是abort是我们主动的动作（也可能是浏览器发出的被动abort），并不是发生真的发生了错误，将其列入error看起来也不合适。</p><p class="mydoc_p"> 其实所有非预想的结果都是异常，所以abort当然也是异常，既然是异常就应该当rejected对待。只是resolved的处理方案因为结果是预期中的，所有处理起来比较容易，但是rejected的处理往往很困难，因为各种异常的处理方法是应该不一样的。比如abort这种异常，如果是因为用户主动操作而产生的异常，那这种异常是不应该提示给用户的，所以abort引起的异常应该包装为特定的异常再进行rejected处理，以便在catch中，可以知道是什么异常，并作出对应的处理。</p><p class="mydoc_p"> 最后一点就是promise里resolved和rejected是不能切换的，所以一旦一个请求得到了响应，就不能再被abort了，而XMLHttpRequest对象是可以随时执行abort的，这一点也是使用promise封装异步请求和直接使用XMLHttpRequest的一个不同点。</p><p class="mydoc_p"> 参考：<a class="mydoc_a" href="https://github.com/camsong/blog/issues/2">https://github.com/camsong/blog/issues/2</a></p>
                    </div>
                </div>
                </div>
            </div>
                </article>