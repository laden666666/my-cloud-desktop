<!doctype html><head><meta charset="utf-8"><style>.mydoc{font-size:14px;overflow:hidden}.mydoc_blockquote{padding:12px 5px 12px 30px;margin:2em 0 0 8px;border-width:0;border-left:4px solid #f66;background-color:#f8f8f8;position:relative;border-bottom-right-radius:2px;border-top-right-radius:2px;line-height:1.6em}.mydoc_blockquote:before{position:absolute;top:14px;left:-12px;background-color:#f66;color:#fff;content:"!";width:20px;height:20px;text-align:center;line-height:20px;font-weight:700;font-family:Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:14px;border-radius:10px}code[class*=language-],pre[class*=language-]{color:#000;background:none;text-shadow:0 1px #fff;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#a67f59;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.mydoc_code{overflow-x:auto;position:relative;background-color:#f8f8f8;padding:0;line-height:1.1em;border-radius:2px;margin:1.2em 0;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AgMAAABHkjHhAAAACVBMVEWAgIBaWlo+Pj7rTFvWAAAAA3RSTlMHCAw+VhR4AAAA+klEQVQoz4WSMW7EQAhFPxKWNh2FCx+HkaZI6RRb5DYbyVfIJXLKDCFoMbaTKSw/8ZnPAPjaH2xgZcUNUDADD7D9LtDBCLZ45fbkvo/30K8yeI64pPwl6znd/3n/Oe93P3ho9qeh72btTFzqkz0rsJle8Zr81OLEwZ1dv/713uWqvu2pl+k0fy7MWtj9r/tN5q/02z89qa/L4Dc2LvM93kezPfXlME/O86EbY/V9GB9ePX8G1/6W+/9h1dq/HGfTfzT3j/xNo7522Bfnqe5jO/fvhVthlfk434v3iO9zG/UOphyPeinPl1J8Gtaa7xPTa/Dk+RIs4deMvwGvcGsmsCvJ0AAAAABJRU5ErkJggg==")}.mydoc_code_pre{padding:1.2em 1.4em;line-height:1.5em;margin:0}.mydoc_h1{margin:0 0 1em}.mydoc_h1_a{color:#2c3e50;text-decoration:none;font-size:2em}.mydoc_h1_h1{margin:45px 0 8px;padding-bottom:7px;font-size:28px}.mydoc_h2{margin:35px 0 .8em}.mydoc_h2_a{font-size:1.5em;text-decoration:none;color:#2c3e50}.mydoc_h2_a:before{content:"";display:block;margin-top:-40px;height:40px;visibility:hidden}.mydoc_h2_h2{margin:5px 0 8px;border-bottom:1px solid #ddd;font-size:22px;padding-bottom:1em}.mydoc_h3{margin:35px 0 .8em}.mydoc_h3_a{font-size:1.3em;text-decoration:none;color:#2c3e50}.mydoc_h3_a:before{content:"";display:block;margin-top:-30px;height:30px;visibility:hidden}.mydoc_h3_h3{margin:5px 0 8px;border-bottom:1px solid #ddd;font-size:18px;padding-bottom:.6em}.mydoc_h4{margin:35px 0 .8em}.mydoc_h4_a{font-size:1.2em;text-decoration:none;color:#2c3e50}.mydoc_h4_a:before{content:"";display:block;margin-top:-20px;height:20px;visibility:hidden}.mydoc_h4_h4{margin:5px 0 8px;border-bottom:1px solid #ddd;font-size:16px;padding-bottom:.3em}.mydoc_table{margin:15px 0 0;padding:0;border:1px solid #aaa;border-collapse:collapse;width:100%;color:#000;font-size:14px;background-color:#fdfcf8}.mydoc_table .mydoc_tr{margin:0;padding:0;border:0;background-color:#fff}.mydoc_table .mydoc_tr:nth-child(odd){background-color:#f5f5f5}.mydoc_table .mydoc_th,.mydoc_table .mydoc_tr:first-child{background-color:#3f3f3f}.mydoc_table .mydoc_th{margin:0;padding:5px 15px 5px 6px;border:1px solid #3f3f3f;vertical-align:baseline;text-align:left;color:#fff;width:123px;word-break:break-all;font-weight:400}.mydoc_table .mydoc_td{word-break:break-all;margin:0;padding:6px 15px 6px 6px;border:1px solid #aaa;vertical-align:text-top}.mydoc_img{display:block;max-width:100%}.mydoc_li:first-child,:not(.mydoc_li)+.mydoc_li{margin-top:10px}.mydoc_li+.mydoc_li{margin-top:-10px}.mydoc_li{margin:0;color:#34495e;margin-bottom:10px;position:relative}.mydoc_p{line-height:1.6em;margin:1.2em 0 -1.2em;padding-bottom:1.2em;position:relative;z-index:1;color:#333}.mydoc_a{color:#42b983;font-weight:400;text-decoration:none;cursor:pointer}.mydoc_strong{font-weight:600;color:#2c3e50}</style></head><article class='mydoc'>
                    <div class="mydoc_h1">
                <a class="mydoc_h1_a">
                    <h1 class="mydoc_h1_h1">通过寄生组合式继承创建js的异常类</h1>
                </a>
                <div class="mydoc_h1_content">
                    <p class="mydoc_p"> 最近项目中在做js的统一的异常处理，需要自定义异常类。理想的设计方案为：自定义一个异常错误类BaseError，继承自Error，然后再自定义若干个系统异常，例如用户取消异常、表单异常、网络异常，这些异常类都继承自BaseError。系统中，根据各个自定义异常做统一的异常处理，例如如果是用户发出取消操作指令，当前调用链则抛出一个用户取消异常，然后由统一异常处理捕获，先判断他是不是继承自BaseError，如果是则再根据事先定义好的处理方案处理。</p><p class="mydoc_p"> 为啥说这只是理想的设计方案呢？因为es5根本就没有提供js的继承语法，更没有提供能够继承自Error的方案。</p><p class="mydoc_p"> 但是，虽然es5的js没有真正意义上的继承方法，但是还是提供了很多折中的方案，例如使用修改原型对象，实现仿继承的方案，参考代码如下</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">function</span> <span class="token function">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">MySonObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
MySonObject<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre>
                </figure><p class="mydoc_p"> 例子代码中，MyObject是父类，他的一个对象赋给了子类MySonObject的原型，这样MySonObject就获取到MyObject的所有属性。通过这种形式，我们可以模拟出继承。</p><p class="mydoc_p"> 然后就是想办法继承自Error。这里先阐明一下为什么要继承自Error，作为异常类最重要一点就是一定要返回错误调用的堆栈信息，否则出错了都不知道到底是哪个地方抛出的，根本无法调试。js语法中，任何对象都可以被throw抛出，但是只有Error抛出才有堆栈信息，如下列测试。</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">try</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token string">"string"</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token keyword">try</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token keyword">try</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span></pre>
                </figure><img class="mydoc_img" src="https://images2015.cnblogs.com/blog/510823/201603/510823-20160310180758913-950638277.png"/><p class="mydoc_p"> 为了能够携带错误的堆栈信息，就必须要有Error对象，如果我们直接“继承”自Error对象，会有什么样的效果呢？在chrome里做如下测试：</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">function</span> <span class="token function">BaseError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
BaseError<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BaseError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span></pre>
                </figure><p class="mydoc_p"> 结果堆栈信息丢了。</p><img class="mydoc_img" src="https://images2015.cnblogs.com/blog/510823/201603/510823-20160310181222679-1744704415.png"/><p class="mydoc_p"> 不能直接继承Error，我们可以在BaseError里面的构造函数里定义Error，这样虽然没有直接继承Error，但是仍然有Error对象作为属性。</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">function</span> <span class="token function">BaseError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment">//或者BaseError.prototype.error = new Error()BaseError.prototype.printError = function(){console.log(this.error.stack)};</span>

<span class="token keyword">function</span> <span class="token function">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
MyError<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BaseError</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></pre>
                </figure><img class="mydoc_img" src="https://images2015.cnblogs.com/blog/510823/201603/510823-20160311012317725-2138103280.png"/><p class="mydoc_p"> 这样写虽然携带了堆栈信息，但是堆栈信息的位置却是“function BaseError(){this.error = new Error()}<span>”这句，而不是“new </span>MyError<span>()”，这样根本就没有什么意义。同样把Error创建过程放入BaseError的原型链上赋值（</span>BaseError.prototype.error = new Error()<span>）一样无法获得正确的堆栈信息。只有把new Error()这句放入子类都构造器里，才能正确显示堆栈信息，不过这样就增加了子类的维护成本，继承的意义也丢失了。</span></p><p class="mydoc_p"> 有没有更好的解决方案呢？问题就这样我们的“继承”方式，因为js中，类的原型也是一个对象，BaseError子类中的原型是一个BaseError实例，所以属性error相当于一个静态属性，各个子类共享了这个error变量，同时仅在声明继承的时候调用了父类的构造函数，不能在子类创建对象时候调用构造函数，这使得Error对象不能在子类创建的时候被创建。所以只有改变目前的这种继承方式，实现Error随子类创建而创建，这样才能返回正确的堆栈信息。</p><p class="mydoc_p"> 因此继续深入地学习js的继承方式，发现被认为是最理想的“寄生组合继承”可以解决这个问题，首先简单介绍一下什么是寄生组合继承。</p><p class="mydoc_p"> 组合继承：因为类似上述我遇到的问题，原型链继承时候父类的属性是静态共享型属性，所以必须要在子类型的构造函数内，通过apply函数调用父类型的构造函数的一种继承方法。代码如下</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">function</span> <span class="token function">BaseError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
BaseError<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">printError</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>error<span class="token punctuation">.</span>stack<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>BaseError<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token keyword">try</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span></pre>
                </figure><p class="mydoc_p"> 这样创建MyError的时候，也调用了BaseError的构造函数，并打印出了正确的堆栈。不过也出现了一个问题，那就是BaseError的printError没有继承到。使用上述代码仅仅继承了属性，却不能继承父类的方法，这样显然也是不能满足需求的。</p><p class="mydoc_p"> 所谓组合继承方式，就是在apply调用超类构造函数继承基础上，再调用原型链继承。</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">function</span> <span class="token function">BaseError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>　　<span class="token keyword">this</span><span class="token punctuation">.</span>error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//为了显示父类的构造方法调用了两次} BaseError.prototype.printError = function(){console.log(this.error.stack)}; function MyError(){BaseError.apply(this);} MyError.prototype = new BaseError() </span>
<span class="token keyword">try</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></pre>
                </figure><p class="mydoc_p"> 打印出结果为</p><img class="mydoc_img" src="https://images2015.cnblogs.com/blog/510823/201603/510823-20160311005214538-1897022432.png"/><p class="mydoc_p"> 从结果看得出基本已经满足了我们的需求，但是需要注意点是父类的构造方法执行了两次，所以执行了两次为了解决这个问题，需要引入另一个js继承方式，即寄生继承。</p><p class="mydoc_p"> 寄生组合继承：寄生继承的核心就是，现将超链的原型赋给另一个寄生类，然后创建这个寄生类的实例，再子类继承这个寄生类实例，这样就去除了原型继承中，需要创建基类的过程，代替为创建一个寄生类。将组合继承和寄生继承同时使用，就是组合寄生继承了。</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">function</span> <span class="token function">BaseError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
BaseError<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">printError</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>error<span class="token punctuation">.</span>stack<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token comment">//构造寄生类</span>
<span class="token keyword">function</span> <span class="token function">parasiticObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
parasiticObject<span class="token punctuation">.</span>prototype <span class="token operator">=</span> BaseError<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>


<span class="token keyword">function</span> <span class="token function">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>BaseError<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> 
MyError<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">parasiticObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token keyword">try</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></pre>
                </figure><img class="mydoc_img" src="https://images2015.cnblogs.com/blog/510823/201603/510823-20160311010904679-1648905499.png"/><p class="mydoc_p"> 这样就解决了所有问题。</p><p class="mydoc_p"> 因为寄生继承导致整个继承的代码过于啰嗦，所有我们一般把继承过程写到一个函数里执行。这样就简化了整个继承代码了，同时也隐藏了无需暴漏的寄生类parasiticObject。</p><figure class='mydoc_code'>
                    <pre class="mydoc_code_pre cm-s-eclipse"><span class="token keyword">function</span> <span class="token function">BaseError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
BaseError<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">printError</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>error<span class="token punctuation">.</span>stack<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token comment">//继承方法</span>
<span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span>superType<span class="token punctuation">,</span>subType<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">var</span> prototype <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span>
    subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span> 
  
<span class="token punctuation">}</span>  

<span class="token keyword">function</span> <span class="token function">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>BaseError<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> 
<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>BaseError<span class="token punctuation">,</span>MyError<span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></pre>
                </figure><p class="mydoc_p"> 这样就完成了整个js异常类的设计。通过寄生组合继承方式，可以很好地实现js的类的继承，并通过创建Error获得错误的堆栈信息，方便调试，也为统一的异常处理机制奠定了基础，下一次将分享我们项目中的统一异常处理的设计。</p>
                </div>
            </div>
                </article>